----- /home/zakaria/sam-learn/discuss/lib/discuss_web/components/layouts.ex -----
defmodule DiscussWeb.Layouts do
  use DiscussWeb, :html

  embed_templates "layouts/*"

  def app(assigns) do
    ~H"""
    <main class="pt-6 pb-12 px-4 sm:px-6 lg:px-8">
      <div class="mx-auto max-w-4xl">
        <%= assigns[:inner_content] || render_slot(@inner_block) %>
      </div>
    </main>
    """
  end
end


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/components/layouts/root.html.heex -----
<!DOCTYPE html>
<html lang="en" class="[scrollbar-gutter:stable]">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="csrf-token" content={get_csrf_token()} />

    <.live_title default="Discuss" suffix=" · Discuss Forum">
      {assigns[:page_title]}
    </.live_title>

    <link phx-track-static rel="stylesheet" href={~p"/assets/app.css"} />
    <script defer phx-track-static type="text/javascript" src={~p"/assets/app.js"}></script>
  </head>

  <body class="bg-gray-50 text-gray-800">
    <.navbar />
    <.app>
      {@inner_content}
    </.app>
  </body>
</html>


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/components/layouts/navbar.html.heex -----
<header class="bg-gradient-to-r from-indigo-600 via-purple-600 to-blue-600 shadow-lg backdrop-blur-sm">
  <div class="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 flex items-center justify-between h-20">
    <!-- Logo + Title -->
    <div class="flex items-center space-x-4 group">
      <a href="/" class="flex items-center space-x-3 transition-transform duration-200 hover:scale-105">
        <div class="relative">
          <div class="absolute inset-0 bg-white/20 rounded-xl blur-sm"></div>
          <img src={~p"/images/logo.svg"} alt="Discuss logo" class="relative h-12 w-12 rounded-xl" />
        </div>
        <h1 class="text-3xl font-bold text-white tracking-tight">
          Discuss
          <span class="block text-xs font-normal text-white/80 mt-1">Community Conversations</span>
        </h1>
      </a>
    </div>

    <!-- Navigation & Auth -->
    <div class="flex items-center space-x-6">
      <!-- Navigation Links -->
      <nav class="hidden md:flex items-center space-x-6">
        <a href="/" class="text-white/90 hover:text-white transition-colors duration-200 font-medium">
          Home
        </a>
        <a href="/topics" class="text-white/90 hover:text-white transition-colors duration-200 font-medium">
          Topics
        </a>
        <a href="#" class="text-white/90 hover:text-white transition-colors duration-200 font-medium">
          About
        </a>
      </nav>

      <!-- Sign On Button -->
      <div class="flex items-center space-x-3">
        <a
          href="#"
          class="group relative inline-flex items-center px-6 py-3 bg-white/10 backdrop-blur-sm
                 border border-white/20 text-sm font-semibold rounded-xl text-white
                 hover:bg-white/20 hover:border-white/30 transition-all duration-200
                 focus:outline-none focus:ring-2 focus:ring-white/50 focus:ring-offset-2 focus:ring-offset-transparent"
        >
          <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
          </svg>
          Sign In
          <div class="absolute inset-0 rounded-xl bg-gradient-to-r from-white/5 to-white/10 opacity-0 group-hover:opacity-100 transition-opacity duration-200"></div>
        </a>
      </div>
    </div>

    <!-- Mobile Menu Button -->
    <div class="md:hidden">
      <button type="button" class="text-white hover:text-white/80 transition-colors">
        <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
      </button>
    </div>
  </div>
</header>


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/components/core_components.ex -----
defmodule DiscussWeb.CoreComponents do
  @moduledoc """
  Provides core UI components.

  At first glance, this module may seem daunting, but its goal is to provide
  core building blocks for your application, such as modals, tables, and
  forms. The components consist mostly of markup and are well-documented
  with doc strings and declarative assigns. You may customize and style
  them in any way you want, based on your application growth and needs.

  The default components use Tailwind CSS, a utility-first CSS framework.
  See the [Tailwind CSS documentation](https://tailwindcss.com) to learn
  how to customize them or feel free to swap in another framework altogether.

  Icons are provided by [heroicons](https://heroicons.com). See `icon/1` for usage.
  """
  use Phoenix.Component
  use Gettext, backend: DiscussWeb.Gettext

  alias Phoenix.LiveView.JS

  @doc """
  Renders a modal.

  ## Examples

      <.modal id="confirm-modal">
        This is a modal.
      </.modal>

  JS commands may be passed to the `:on_cancel` to configure
  the closing/cancel event, for example:

      <.modal id="confirm" on_cancel={JS.navigate(~p"/posts")}>
        This is another modal.
      </.modal>

  """
  attr :id, :string, required: true
  attr :show, :boolean, default: false
  attr :on_cancel, JS, default: %JS{}
  slot :inner_block, required: true

  def modal(assigns) do
    ~H"""
    <div
      id={@id}
      phx-mounted={@show && show_modal(@id)}
      phx-remove={hide_modal(@id)}
      data-cancel={JS.exec(@on_cancel, "phx-remove")}
      class="relative z-50 hidden"
    >
      <div id={"#{@id}-bg"} class="bg-zinc-50/90 fixed inset-0 transition-opacity" aria-hidden="true" />
      <div
        class="fixed inset-0 overflow-y-auto"
        aria-labelledby={"#{@id}-title"}
        aria-describedby={"#{@id}-description"}
        role="dialog"
        aria-modal="true"
        tabindex="0"
      >
        <div class="flex min-h-full items-center justify-center">
          <div class="w-full max-w-3xl p-4 sm:p-6 lg:py-8">
            <.focus_wrap
              id={"#{@id}-container"}
              phx-window-keydown={JS.exec("data-cancel", to: "##{@id}")}
              phx-key="escape"
              phx-click-away={JS.exec("data-cancel", to: "##{@id}")}
              class="shadow-zinc-700/10 ring-zinc-700/10 relative hidden rounded-2xl bg-white p-14 shadow-lg ring-1 transition"
            >
              <div class="absolute top-6 right-5">
                <button
                  phx-click={JS.exec("data-cancel", to: "##{@id}")}
                  type="button"
                  class="-m-3 flex-none p-3 opacity-20 hover:opacity-40"
                  aria-label={gettext("close")}
                >
                  <.icon name="hero-x-mark-solid" class="h-5 w-5" />
                </button>
              </div>
              <div id={"#{@id}-content"}>
                {render_slot(@inner_block)}
              </div>
            </.focus_wrap>
          </div>
        </div>
      </div>
    </div>
    """
  end

  @doc """
  Renders flash notices.

  ## Examples

      <.flash kind={:info} flash={@flash} />
      <.flash kind={:info} phx-mounted={show("#flash")}>Welcome Back!</.flash>
  """
  attr :id, :string, doc: "the optional id of flash container"
  attr :flash, :map, default: %{}, doc: "the map of flash messages to display"
  attr :title, :string, default: nil
  attr :kind, :atom, values: [:info, :error], doc: "used for styling and flash lookup"
  attr :rest, :global, doc: "the arbitrary HTML attributes to add to the flash container"

  slot :inner_block, doc: "the optional inner block that renders the flash message"

  def flash(assigns) do
    assigns = assign_new(assigns, :id, fn -> "flash-#{assigns.kind}" end)

    ~H"""
    <div
      :if={msg = render_slot(@inner_block) || Phoenix.Flash.get(@flash, @kind)}
      id={@id}
      phx-click={JS.push("lv:clear-flash", value: %{key: @kind}) |> hide("##{@id}")}
      role="alert"
      class={[
        "fixed top-2 right-2 mr-2 w-80 sm:w-96 z-50 rounded-lg p-3 ring-1",
        @kind == :info && "bg-emerald-50 text-emerald-800 ring-emerald-500 fill-cyan-900",
        @kind == :error && "bg-rose-50 text-rose-900 shadow-md ring-rose-500 fill-rose-900"
      ]}
      {@rest}
    >
      <p :if={@title} class="flex items-center gap-1.5 text-sm font-semibold leading-6">
        <.icon :if={@kind == :info} name="hero-information-circle-mini" class="h-4 w-4" />
        <.icon :if={@kind == :error} name="hero-exclamation-circle-mini" class="h-4 w-4" />
        {@title}
      </p>
      <p class="mt-2 text-sm leading-5">{msg}</p>
      <button type="button" class="group absolute top-1 right-1 p-2" aria-label={gettext("close")}>
        <.icon name="hero-x-mark-solid" class="h-5 w-5 opacity-40 group-hover:opacity-70" />
      </button>
    </div>
    """
  end

  @doc """
  Shows the flash group with standard titles and content.

  ## Examples

      <.flash_group flash={@flash} />
  """
  attr :flash, :map, required: true, doc: "the map of flash messages"
  attr :id, :string, default: "flash-group", doc: "the optional id of flash container"

  def flash_group(assigns) do
    ~H"""
    <div id={@id}>
      <.flash kind={:info} title={gettext("Success!")} flash={@flash} />
      <.flash kind={:error} title={gettext("Error!")} flash={@flash} />
      <.flash
        id="client-error"
        kind={:error}
        title={gettext("We can't find the internet")}
        phx-disconnected={show(".phx-client-error #client-error")}
        phx-connected={hide("#client-error")}
        hidden
      >
        {gettext("Attempting to reconnect")}
        <.icon name="hero-arrow-path" class="ml-1 h-3 w-3 animate-spin" />
      </.flash>

      <.flash
        id="server-error"
        kind={:error}
        title={gettext("Something went wrong!")}
        phx-disconnected={show(".phx-server-error #server-error")}
        phx-connected={hide("#server-error")}
        hidden
      >
        {gettext("Hang in there while we get back on track")}
        <.icon name="hero-arrow-path" class="ml-1 h-3 w-3 animate-spin" />
      </.flash>
    </div>
    """
  end

  @doc """
  Renders a simple form.

  ## Examples

      <.simple_form for={@form} phx-change="validate" phx-submit="save">
        <.input field={@form[:email]} label="Email"/>
        <.input field={@form[:username]} label="Username" />
        <:actions>
          <.button>Save</.button>
        </:actions>
      </.simple_form>
  """
  attr :for, :any, required: true, doc: "the data structure for the form"
  attr :as, :any, default: nil, doc: "the server side parameter to collect all input under"

  attr :rest, :global,
    include: ~w(autocomplete name rel action enctype method novalidate target multipart),
    doc: "the arbitrary HTML attributes to apply to the form tag"

  slot :inner_block, required: true
  slot :actions, doc: "the slot for form actions, such as a submit button"

  def simple_form(assigns) do
    ~H"""
    <.form :let={f} for={@for} as={@as} {@rest}>
      <div class="mt-10 space-y-8 bg-white">
        {render_slot(@inner_block, f)}
        <div :for={action <- @actions} class="mt-2 flex items-center justify-between gap-6">
          {render_slot(action, f)}
        </div>
      </div>
    </.form>
    """
  end

  @doc """
  Renders a button.

  ## Examples

      <.button>Send!</.button>
      <.button phx-click="go" class="ml-2">Send!</.button>
  """
  attr :type, :string, default: nil
  attr :class, :string, default: nil
  attr :rest, :global, include: ~w(disabled form name value)

  slot :inner_block, required: true

  def button(assigns) do
    ~H"""
    <button
      type={@type}
      class={[
        "phx-submit-loading:opacity-75 rounded-lg bg-zinc-900 hover:bg-zinc-700 py-2 px-3",
        "text-sm font-semibold leading-6 text-white active:text-white/80",
        @class
      ]}
      {@rest}
    >
      {render_slot(@inner_block)}
    </button>
    """
  end

  @doc """
  Renders an input with label and error messages.

  A `Phoenix.HTML.FormField` may be passed as argument,
  which is used to retrieve the input name, id, and values.
  Otherwise all attributes may be passed explicitly.

  ## Types

  This function accepts all HTML input types, considering that:

    * You may also set `type="select"` to render a `<select>` tag

    * `type="checkbox"` is used exclusively to render boolean values

    * For live file uploads, see `Phoenix.Component.live_file_input/1`

  See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input
  for more information. Unsupported types, such as hidden and radio,
  are best written directly in your templates.

  ## Examples

      <.input field={@form[:email]} type="email" />
      <.input name="my-input" errors={["oh no!"]} />
  """
  attr :id, :any, default: nil
  attr :name, :any
  attr :label, :string, default: nil
  attr :value, :any

  attr :type, :string,
    default: "text",
    values: ~w(checkbox color date datetime-local email file month number password
               range search select tel text textarea time url week)

  attr :field, Phoenix.HTML.FormField,
    doc: "a form field struct retrieved from the form, for example: @form[:email]"

  attr :errors, :list, default: []
  attr :checked, :boolean, doc: "the checked flag for checkbox inputs"
  attr :prompt, :string, default: nil, doc: "the prompt for select inputs"
  attr :options, :list, doc: "the options to pass to Phoenix.HTML.Form.options_for_select/2"
  attr :multiple, :boolean, default: false, doc: "the multiple flag for select inputs"

  attr :rest, :global,
    include: ~w(accept autocomplete capture cols disabled form list max maxlength min minlength
                multiple pattern placeholder readonly required rows size step)

  def input(%{field: %Phoenix.HTML.FormField{} = field} = assigns) do
    errors = if Phoenix.Component.used_input?(field), do: field.errors, else: []

    assigns
    |> assign(field: nil, id: assigns.id || field.id)
    |> assign(:errors, Enum.map(errors, &translate_error(&1)))
    |> assign_new(:name, fn -> if assigns.multiple, do: field.name <> "[]", else: field.name end)
    |> assign_new(:value, fn -> field.value end)
    |> input()
  end

  def input(%{type: "checkbox"} = assigns) do
    assigns =
      assign_new(assigns, :checked, fn ->
        Phoenix.HTML.Form.normalize_value("checkbox", assigns[:value])
      end)

    ~H"""
    <div>
      <label class="flex items-center gap-4 text-sm leading-6 text-zinc-600">
        <input type="hidden" name={@name} value="false" disabled={@rest[:disabled]} />
        <input
          type="checkbox"
          id={@id}
          name={@name}
          value="true"
          checked={@checked}
          class="rounded border-zinc-300 text-zinc-900 focus:ring-0"
          {@rest}
        />
        {@label}
      </label>
      <.error :for={msg <- @errors}>{msg}</.error>
    </div>
    """
  end

  def input(%{type: "select"} = assigns) do
    ~H"""
    <div>
      <.label for={@id}>{@label}</.label>
      <select
        id={@id}
        name={@name}
        class="mt-2 block w-full rounded-md border border-gray-300 bg-white shadow-sm focus:border-zinc-400 focus:ring-0 sm:text-sm"
        multiple={@multiple}
        {@rest}
      >
        <option :if={@prompt} value="">{@prompt}</option>
        {Phoenix.HTML.Form.options_for_select(@options, @value)}
      </select>
      <.error :for={msg <- @errors}>{msg}</.error>
    </div>
    """
  end

  def input(%{type: "textarea"} = assigns) do
    ~H"""
    <div>
      <.label for={@id}>{@label}</.label>
      <textarea
        id={@id}
        name={@name}
        class={[
          "mt-2 block w-full rounded-lg text-zinc-900 focus:ring-0 sm:text-sm sm:leading-6 min-h-[6rem]",
          @errors == [] && "border-zinc-300 focus:border-zinc-400",
          @errors != [] && "border-rose-400 focus:border-rose-400"
        ]}
        {@rest}
      >{Phoenix.HTML.Form.normalize_value("textarea", @value)}</textarea>
      <.error :for={msg <- @errors}>{msg}</.error>
    </div>
    """
  end

  # All other inputs text, datetime-local, url, password, etc. are handled here...
  def input(assigns) do
    ~H"""
    <div>
      <.label for={@id}>{@label}</.label>
      <input
        type={@type}
        name={@name}
        id={@id}
        value={Phoenix.HTML.Form.normalize_value(@type, @value)}
        class={[
          "mt-2 block w-full rounded-lg text-zinc-900 focus:ring-0 sm:text-sm sm:leading-6",
          @errors == [] && "border-zinc-300 focus:border-zinc-400",
          @errors != [] && "border-rose-400 focus:border-rose-400"
        ]}
        {@rest}
      />
      <.error :for={msg <- @errors}>{msg}</.error>
    </div>
    """
  end

  @doc """
  Renders a label.
  """
  attr :for, :string, default: nil
  slot :inner_block, required: true

  def label(assigns) do
    ~H"""
    <label for={@for} class="block text-sm font-semibold leading-6 text-zinc-800">
      {render_slot(@inner_block)}
    </label>
    """
  end

  @doc """
  Generates a generic error message.
  """
  slot :inner_block, required: true

  def error(assigns) do
    ~H"""
    <p class="mt-3 flex gap-3 text-sm leading-6 text-rose-600">
      <.icon name="hero-exclamation-circle-mini" class="mt-0.5 h-5 w-5 flex-none" />
      {render_slot(@inner_block)}
    </p>
    """
  end

  @doc """
  Renders a header with title.
  """
  attr :class, :string, default: nil

  slot :inner_block, required: true
  slot :subtitle
  slot :actions

  def header(assigns) do
    ~H"""
    <header class={[@actions != [] && "flex items-center justify-between gap-6", @class]}>
      <div>
        <h1 class="text-lg font-semibold leading-8 text-zinc-800">
          {render_slot(@inner_block)}
        </h1>
        <p :if={@subtitle != []} class="mt-2 text-sm leading-6 text-zinc-600">
          {render_slot(@subtitle)}
        </p>
      </div>
      <div class="flex-none">{render_slot(@actions)}</div>
    </header>
    """
  end

  @doc ~S"""
  Renders a table with generic styling.

  ## Examples

      <.table id="users" rows={@users}>
        <:col :let={user} label="id">{user.id}</:col>
        <:col :let={user} label="username">{user.username}</:col>
      </.table>
  """
  attr :id, :string, required: true
  attr :rows, :list, required: true
  attr :row_id, :any, default: nil, doc: "the function for generating the row id"
  attr :row_click, :any, default: nil, doc: "the function for handling phx-click on each row"

  attr :row_item, :any,
    default: &Function.identity/1,
    doc: "the function for mapping each row before calling the :col and :action slots"

  slot :col, required: true do
    attr :label, :string
  end

  slot :action, doc: "the slot for showing user actions in the last table column"

  def table(assigns) do
    assigns =
      with %{rows: %Phoenix.LiveView.LiveStream{}} <- assigns do
        assign(assigns, row_id: assigns.row_id || fn {id, _item} -> id end)
      end

    ~H"""
    <div class="overflow-y-auto px-4 sm:overflow-visible sm:px-0">
      <table class="w-[40rem] mt-11 sm:w-full">
        <thead class="text-sm text-left leading-6 text-zinc-500">
          <tr>
            <th :for={col <- @col} class="p-0 pb-4 pr-6 font-normal">{col[:label]}</th>
            <th :if={@action != []} class="relative p-0 pb-4">
              <span class="sr-only">{gettext("Actions")}</span>
            </th>
          </tr>
        </thead>
        <tbody
          id={@id}
          phx-update={match?(%Phoenix.LiveView.LiveStream{}, @rows) && "stream"}
          class="relative divide-y divide-zinc-100 border-t border-zinc-200 text-sm leading-6 text-zinc-700"
        >
          <tr :for={row <- @rows} id={@row_id && @row_id.(row)} class="group hover:bg-zinc-50">
            <td
              :for={{col, i} <- Enum.with_index(@col)}
              phx-click={@row_click && @row_click.(row)}
              class={["relative p-0", @row_click && "hover:cursor-pointer"]}
            >
              <div class="block py-4 pr-6">
                <span class="absolute -inset-y-px right-0 -left-4 group-hover:bg-zinc-50 sm:rounded-l-xl" />
                <span class={["relative", i == 0 && "font-semibold text-zinc-900"]}>
                  {render_slot(col, @row_item.(row))}
                </span>
              </div>
            </td>
            <td :if={@action != []} class="relative w-14 p-0">
              <div class="relative whitespace-nowrap py-4 text-right text-sm font-medium">
                <span class="absolute -inset-y-px -right-4 left-0 group-hover:bg-zinc-50 sm:rounded-r-xl" />
                <span
                  :for={action <- @action}
                  class="relative ml-4 font-semibold leading-6 text-zinc-900 hover:text-zinc-700"
                >
                  {render_slot(action, @row_item.(row))}
                </span>
              </div>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    """
  end

  @doc """
  Renders a data list.

  ## Examples

      <.list>
        <:item title="Title">{@post.title}</:item>
        <:item title="Views">{@post.views}</:item>
      </.list>
  """
  slot :item, required: true do
    attr :title, :string, required: true
  end

  def list(assigns) do
    ~H"""
    <div class="mt-14">
      <dl class="-my-4 divide-y divide-zinc-100">
        <div :for={item <- @item} class="flex gap-4 py-4 text-sm leading-6 sm:gap-8">
          <dt class="w-1/4 flex-none text-zinc-500">{item.title}</dt>
          <dd class="text-zinc-700">{render_slot(item)}</dd>
        </div>
      </dl>
    </div>
    """
  end

  @doc """
  Renders a back navigation link.

  ## Examples

      <.back navigate={~p"/posts"}>Back to posts</.back>
  """
  attr :navigate, :any, required: true
  slot :inner_block, required: true

  def back(assigns) do
    ~H"""
    <div class="mt-16">
      <.link
        navigate={@navigate}
        class="text-sm font-semibold leading-6 text-zinc-900 hover:text-zinc-700"
      >
        <.icon name="hero-arrow-left-solid" class="h-3 w-3" />
        {render_slot(@inner_block)}
      </.link>
    </div>
    """
  end

  @doc """
  Renders a [Heroicon](https://heroicons.com).

  Heroicons come in three styles – outline, solid, and mini.
  By default, the outline style is used, but solid and mini may
  be applied by using the `-solid` and `-mini` suffix.

  You can customize the size and colors of the icons by setting
  width, height, and background color classes.

  Icons are extracted from the `deps/heroicons` directory and bundled within
  your compiled app.css by the plugin in your `assets/tailwind.config.js`.

  ## Examples

      <.icon name="hero-x-mark-solid" />
      <.icon name="hero-arrow-path" class="ml-1 w-3 h-3 animate-spin" />
  """
  attr :name, :string, required: true
  attr :class, :string, default: nil

  def icon(%{name: "hero-" <> _} = assigns) do
    ~H"""
    <span class={[@name, @class]} />
    """
  end

  ## JS Commands

  def show(js \\ %JS{}, selector) do
    JS.show(js,
      to: selector,
      time: 300,
      transition:
        {"transition-all transform ease-out duration-300",
         "opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95",
         "opacity-100 translate-y-0 sm:scale-100"}
    )
  end

  def hide(js \\ %JS{}, selector) do
    JS.hide(js,
      to: selector,
      time: 200,
      transition:
        {"transition-all transform ease-in duration-200",
         "opacity-100 translate-y-0 sm:scale-100",
         "opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"}
    )
  end

  def show_modal(js \\ %JS{}, id) when is_binary(id) do
    js
    |> JS.show(to: "##{id}")
    |> JS.show(
      to: "##{id}-bg",
      time: 300,
      transition: {"transition-all transform ease-out duration-300", "opacity-0", "opacity-100"}
    )
    |> show("##{id}-container")
    |> JS.add_class("overflow-hidden", to: "body")
    |> JS.focus_first(to: "##{id}-content")
  end

  def hide_modal(js \\ %JS{}, id) do
    js
    |> JS.hide(
      to: "##{id}-bg",
      transition: {"transition-all transform ease-in duration-200", "opacity-100", "opacity-0"}
    )
    |> hide("##{id}-container")
    |> JS.hide(to: "##{id}", transition: {"block", "block", "hidden"})
    |> JS.remove_class("overflow-hidden", to: "body")
    |> JS.pop_focus()
  end

  @doc """
  Translates an error message using gettext.
  """
  def translate_error({msg, opts}) do
    # When using gettext, we typically pass the strings we want
    # to translate as a static argument:
    #
    #     # Translate the number of files with plural rules
    #     dngettext("errors", "1 file", "%{count} files", count)
    #
    # However the error messages in our forms and APIs are generated
    # dynamically, so we need to translate them by calling Gettext
    # with our gettext backend as first argument. Translations are
    # available in the errors.po file (as we use the "errors" domain).
    if count = opts[:count] do
      Gettext.dngettext(DiscussWeb.Gettext, "errors", msg, msg, count, opts)
    else
      Gettext.dgettext(DiscussWeb.Gettext, "errors", msg, opts)
    end
  end

  @doc """
  Translates the errors for a field from a keyword list of errors.
  """
  def translate_errors(errors, field) when is_list(errors) do
    for {^field, {msg, opts}} <- errors, do: translate_error({msg, opts})
  end
end


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/telemetry.ex -----
defmodule DiscussWeb.Telemetry do
  use Supervisor
  import Telemetry.Metrics

  def start_link(arg) do
    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)
  end

  @impl true
  def init(_arg) do
    children = [
      # Telemetry poller will execute the given period measurements
      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics
      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}
      # Add reporters as children of your supervision tree.
      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}
    ]

    Supervisor.init(children, strategy: :one_for_one)
  end

  def metrics do
    [
      # Phoenix Metrics
      summary("phoenix.endpoint.start.system_time",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.endpoint.stop.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.start.system_time",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.exception.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.router_dispatch.stop.duration",
        tags: [:route],
        unit: {:native, :millisecond}
      ),
      summary("phoenix.socket_connected.duration",
        unit: {:native, :millisecond}
      ),
      sum("phoenix.socket_drain.count"),
      summary("phoenix.channel_joined.duration",
        unit: {:native, :millisecond}
      ),
      summary("phoenix.channel_handled_in.duration",
        tags: [:event],
        unit: {:native, :millisecond}
      ),

      # Database Metrics
      summary("discuss.repo.query.total_time",
        unit: {:native, :millisecond},
        description: "The sum of the other measurements"
      ),
      summary("discuss.repo.query.decode_time",
        unit: {:native, :millisecond},
        description: "The time spent decoding the data received from the database"
      ),
      summary("discuss.repo.query.query_time",
        unit: {:native, :millisecond},
        description: "The time spent executing the query"
      ),
      summary("discuss.repo.query.queue_time",
        unit: {:native, :millisecond},
        description: "The time spent waiting for a database connection"
      ),
      summary("discuss.repo.query.idle_time",
        unit: {:native, :millisecond},
        description:
          "The time the connection spent waiting before being checked out for the query"
      ),

      # VM Metrics
      summary("vm.memory.total", unit: {:byte, :kilobyte}),
      summary("vm.total_run_queue_lengths.total"),
      summary("vm.total_run_queue_lengths.cpu"),
      summary("vm.total_run_queue_lengths.io")
    ]
  end

  defp periodic_measurements do
    [
      # A module, function and arguments to be invoked periodically.
      # This function must call :telemetry.execute/3 and a metric must be added above.
      # {DiscussWeb, :count_users, []}
    ]
  end
end


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/controllers/page_html.ex -----
defmodule DiscussWeb.PageHTML do
  @moduledoc """
  This module contains pages rendered by PageController.

  See the `page_html` directory for all templates available.
  """
  use DiscussWeb, :html

  embed_templates "page_html/*"
end


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/controllers/error_html.ex -----
defmodule DiscussWeb.ErrorHTML do
  @moduledoc """
  This module is invoked by your endpoint in case of errors on HTML requests.

  See config/config.exs.
  """
  use DiscussWeb, :html

  # If you want to customize your error pages,
  # uncomment the embed_templates/1 call below
  # and add pages to the error directory:
  #
  #   * lib/discuss_web/controllers/error_html/404.html.heex
  #   * lib/discuss_web/controllers/error_html/500.html.heex
  #
  # embed_templates "error_html/*"

  # The default is to render a plain text page based on
  # the template name. For example, "404.html" becomes
  # "Not Found".
  def render(template, _assigns) do
    Phoenix.Controller.status_message_from_template(template)
  end
end


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/controllers/error_json.ex -----
defmodule DiscussWeb.ErrorJSON do
  @moduledoc """
  This module is invoked by your endpoint in case of errors on JSON requests.

  See config/config.exs.
  """

  # If you want to customize a particular status code,
  # you may add your own clauses, such as:
  #
  # def render("500.json", _assigns) do
  #   %{errors: %{detail: "Internal Server Error"}}
  # end

  # By default, Phoenix returns the status message from
  # the template name. For example, "404.json" becomes
  # "Not Found".
  def render(template, _assigns) do
    %{errors: %{detail: Phoenix.Controller.status_message_from_template(template)}}
  end
end


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/controllers/page_html/home.html.heex -----
<.flash_group flash={@flash}/>

<section class="text-center mt-12">
  <h2 class="text-4xl font-extrabold text-gray-900 mb-4">Welcome to Discuss</h2>
  <p class="text-lg text-gray-600 mb-8">
    A community‑driven forum where you can post topics, share opinions, and join the conversation.
  </p>
  <.link
    navigate={~p"/topics/new"}
    class="inline-block px-6 py-3 bg-indigo-600 text-white font-medium rounded-md hover:bg-indigo-700"
  >
    Start a New Topic
  </.link>
</section>

<section class="mt-16">
  <h3 class="text-2xl font-semibold text-gray-800 mb-4">Recent Topics</h3>

  <%= if Enum.empty?(@topics) do %>
    <p class="text-gray-600">
      No topics yet. 
      <.link navigate={~p"/topics/new"} class="underline">Create the first one.</.link>
    </p>
  <% else %>
    <ul class="space-y-4">
      <%= for topic <- @topics do %>
        <li class="p-4 bg-white rounded shadow-sm hover:shadow-md transition">
          <h4 class="text-lg font-medium text-indigo-600 hover:underline">
            <.link navigate={~p"/topics/#{topic.id}"}>
              <%= topic.title %>
            </.link>
          </h4>
          <p class="text-gray-500 text-sm mt-1">
            Posted <%= NaiveDateTime.to_date(topic.inserted_at) %>
          </p>
        </li>
      <% end %>
    </ul>
  <% end %>
</section>


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/controllers/page_controller.ex -----
defmodule DiscussWeb.PageController do
  use DiscussWeb, :controller

  # Bring in our Content context to fetch topics
  alias Discuss.Content

  @doc """
  GET /
  Renders the home page, loading the 5 most recent topics.
  """

  def home(conn, _params) do
    # fetch the latest 5 topics, ordered by insertion time descending
    topics = Content.recent_topics(5)

    # Render the home.html.heex template, passing topics: topics
    render(conn, :home, topics: topics)
  end
end


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/controllers/topic_html.ex -----
defmodule DiscussWeb.TopicHTML do
  @moduledoc """
  This module contains pages rendered by TopicController.

  See the `topic_html` directory for all templates available.
  """
  use DiscussWeb, :html

  embed_templates "topic_html/*"

  def form_component(assigns) do
    ~H"""
    <.simple_form :let={f} for={@form} id="topic-form" action={@action}>
      <.input field={f[:title]} label="Title" />
      <.input field={f[:body]} label="Body" type="textarea" />

      <:actions>
        <.button type="submit">
          <%= if @form.data.id, do: "Update Topic", else: "Create Topic" %>
        </.button>

        <%= if @form.data.id do %>
          <.link navigate={~p"/topics/#{@form.data.id}"} class="ml-4 text-sm text-gray-600 hover:underline">
            Cancel
          </.link>
        <% else %>
          <.link navigate={~p"/topics"} class="ml-4 text-sm text-gray-600 hover:underline">
            Back to Topics
          </.link>
        <% end %>
      </:actions>
    </.simple_form>
    """
  end
end


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/controllers/topic_controller.ex -----
defmodule DiscussWeb.TopicController do
  use DiscussWeb, :controller

  alias Discuss.Content
  alias Discuss.Content.Topic

  @doc """
  GET /topics
  Lists all topics and renders the index page.
  """
  def index(conn, _params) do
    topics = Content.list_topics()
    render(conn, :index, topics: topics)
  end

  @doc """
  GET /topics/new
  Renders the form for creating a new topic.
  """
  def new(conn, _params) do
    changeset = Content.change_topic(%Topic{})
    render(conn, :new, changeset: changeset)
  end

  @doc """
  POST /topics
  Attempts to create a topic. On success, flashes and redirects to show;
  on error, re‑renders the form with errors.
  """
  def create(conn, %{"topic" => topic_params}) do
    case Content.create_topic(topic_params) do
      {:ok, topic} ->
        conn
        |> put_flash(:info, "Topic created successfully!")
        |> redirect(to: ~p"/topics/#{topic.id}")

      {:error, %Ecto.Changeset{} = changeset} ->
        render(conn, :new, changeset: changeset)
    end
  end

  @doc """
  GET /topics/:id
  Shows a single topic.
  """
  def show(conn, %{"id" => id}) do
    topic = Content.get_topic!(id)
    render(conn, :show, topic: topic)
  end

  @doc """
  GET /topics/:id/edit
  Renders the edit form for a topic.
  """
  def edit(conn, %{"id" => id}) do
    topic = Content.get_topic!(id)
    changeset = Content.change_topic(topic)
    render(conn, :edit, topic: topic, changeset: changeset)
  end

  @doc """
  PATCH/PUT /topics/:id
  Attempts to update a topic. On success, flashes and redirects to show;
  on error, re‑renders the edit form with errors.
  """
  def update(conn, %{"id" => id, "topic" => topic_params}) do
    topic = Content.get_topic!(id)

    case Content.update_topic(topic, topic_params) do
      {:ok, topic} ->
        conn
        |> put_flash(:info, "Topic updated successfully!")
        |> redirect(to: ~p"/topics/#{topic.id}")

      {:error, %Ecto.Changeset{} = changeset} ->
        render(conn, :edit, topic: topic, changeset: changeset)
    end
  end

  @doc """
  DELETE /topics/:id
  Deletes the topic and redirects back to the list.
  """
  def delete(conn, %{"id" => id}) do
    topic = Content.get_topic!(id)
    {:ok, _} = Content.delete_topic(topic)

    conn
    |> put_flash(:info, "Topic deleted successfully!")
    |> redirect(to: ~p"/topics")
  end
end


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/controllers/topic_html/show.html.heex -----
<div class="flex items-center justify-between mb-6">
  <h1 class="text-3xl font-bold"><%= @topic.title %></h1>
  <div class="space-x-2">
    <.link navigate={~p"/topics/#{@topic.id}/edit"} class="px-3 py-1 bg-yellow-500 text-white rounded hover:bg-yellow-600">
      Edit
    </.link>
    <.link navigate={~p"/topics"} class="px-3 py-1 bg-gray-200 text-gray-700 rounded hover:bg-gray-300">
      Back
    </.link>
  </div>
</div>

<div class="prose prose-lg bg-white p-6 rounded shadow">
  <%= raw @topic.body |> Earmark.as_html!() %>
</div>

<div class="mt-6">
  <.button phx-click="delete" phx-value-id={@topic.id} form="delete-topic-form" class="bg-red-600 hover:bg-red-700">
    Delete Topic
  </.button>

  <.form for={%{}} action={~p"/topics/#{@topic.id}"} id="delete-topic-form" method="post" class="hidden">
    <input type="hidden" name="_method" value="delete" />
  </.form>
</div>


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/controllers/topic_html/index.html.heex -----
<div class="flex items-center justify-between mb-6">
  <h1 class="text-3xl font-bold">Topics</h1>
  <.link navigate={~p"/topics/new"} class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">
    New Topic
  </.link>
</div>

<%= if Enum.empty?(@topics) do %>
  <p class="text-gray-600">
    No topics yet. <.link navigate={~p"/topics/new"} class="underline">Create one?</.link>
  </p>
<% else %>
  <ul class="space-y-4">
    <%= for topic <- @topics do %>
      <li class="p-4 bg-white rounded shadow hover:shadow-md transition">
        <h2 class="text-xl font-semibold">
          <.link navigate={~p"/topics/#{topic.id}"} class="hover:underline">
            <%= topic.title %>
          </.link>
        </h2>
        <p class="mt-1 text-gray-500 text-sm">
          <!-- Simple date; or add Timex if you prefer -->
          <%= NaiveDateTime.to_date(topic.inserted_at) %>
        </p>
      </li>
    <% end %>
  </ul>
<% end %>


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/controllers/topic_html/_form.html.heex -----
<.simple_form for={@changeset} id="topic-form" phx-submit={@action} action={@action}>
  <.input field={@changeset[:title]} label="Title" />
  <.input field={@changeset[:body]} label="Body" type="textarea" />

  <:actions>
    <.button type="submit">
      <%= if @changeset.data.id, do: "Update Topic", else: "Create Topic" %>
    </.button>

    <%= if @changeset.data.id do %>
      <.link navigate={~p"/topics/#{@changeset.data.id}"} class="ml-4 text-sm text-gray-600 hover:underline">
        Cancel
      </.link>
    <% else %>
      <.link navigate={~p"/topics"} class="ml-4 text-sm text-gray-600 hover:underline">
        Back to Topics
      </.link>
    <% end %>
  </:actions>
</.simple_form>


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/controllers/topic_html/edit.html.heex -----
<div class="max-w-2xl mx-auto">
  <h1 class="text-3xl font-bold mb-4">Edit Topic</h1>
  <.form_component form={@changeset} action={~p"/topics/#{@topic.id}"} />
</div>


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/controllers/topic_html/new.html.heex -----
<div class="max-w-2xl mx-auto">
  <h1 class="text-3xl font-bold mb-4">New Topic</h1>
  <.form_component form={@changeset} action={~p"/topics"} />
</div>


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/gettext.ex -----
defmodule DiscussWeb.Gettext do
  @moduledoc """
  A module providing Internationalization with a gettext-based API.

  By using [Gettext](https://hexdocs.pm/gettext), your module compiles translations
  that you can use in your application. To use this Gettext backend module,
  call `use Gettext` and pass it as an option:

      use Gettext, backend: DiscussWeb.Gettext

      # Simple translation
      gettext("Here is the string to translate")

      # Plural translation
      ngettext("Here is the string to translate",
               "Here are the strings to translate",
               3)

      # Domain-based translation
      dgettext("errors", "Here is the error message to translate")

  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.
  """
  use Gettext.Backend, otp_app: :discuss
end


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/router.ex -----
defmodule DiscussWeb.Router do
  use DiscussWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_live_flash
    plug :put_root_layout, html: {DiscussWeb.Layouts, :root}
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
  end

  scope "/", DiscussWeb do
    pipe_through :browser

    get "/", PageController, :home
    resources "/topics", TopicController
  end

  # Other scopes may use custom stacks.
  # scope "/api", DiscussWeb do
  #   pipe_through :api
  # end

  # Enable LiveDashboard and Swoosh mailbox preview in development
  if Application.compile_env(:discuss, :dev_routes) do
    # If you want to use the LiveDashboard in production, you should put
    # it behind authentication and allow only admins to access it.
    # If your application does not have an admins-only section yet,
    # you can use Plug.BasicAuth to set up some basic authentication
    # as long as you are also using SSL (which you should anyway).
    import Phoenix.LiveDashboard.Router

    scope "/dev" do
      pipe_through :browser

      live_dashboard "/dashboard", metrics: DiscussWeb.Telemetry
      forward "/mailbox", Plug.Swoosh.MailboxPreview
    end
  end
end


----- /home/zakaria/sam-learn/discuss/lib/discuss_web/endpoint.ex -----
defmodule DiscussWeb.Endpoint do
  use Phoenix.Endpoint, otp_app: :discuss

  # The session will be stored in the cookie and signed,
  # this means its contents can be read but not tampered with.
  # Set :encryption_salt if you would also like to encrypt it.
  @session_options [
    store: :cookie,
    key: "_discuss_key",
    signing_salt: "Qohge0YU",
    same_site: "Lax"
  ]

  socket "/live", Phoenix.LiveView.Socket,
    websocket: [connect_info: [session: @session_options]],
    longpoll: [connect_info: [session: @session_options]]

  # Serve at "/" the static files from "priv/static" directory.
  #
  # You should set gzip to true if you are running phx.digest
  # when deploying your static files in production.
  plug Plug.Static,
    at: "/",
    from: :discuss,
    gzip: false,
    only: DiscussWeb.static_paths()

  # Code reloading can be explicitly enabled under the
  # :code_reloader configuration of your endpoint.
  if code_reloading? do
    socket "/phoenix/live_reload/socket", Phoenix.LiveReloader.Socket
    plug Phoenix.LiveReloader
    plug Phoenix.CodeReloader
    plug Phoenix.Ecto.CheckRepoStatus, otp_app: :discuss
  end

  plug Phoenix.LiveDashboard.RequestLogger,
    param_key: "request_logger",
    cookie_key: "request_logger"

  plug Plug.RequestId
  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]

  plug Plug.Parsers,
    parsers: [:urlencoded, :multipart, :json],
    pass: ["*/*"],
    json_decoder: Phoenix.json_library()

  plug Plug.MethodOverride
  plug Plug.Head
  plug Plug.Session, @session_options
  plug DiscussWeb.Router
end


----- /home/zakaria/sam-learn/discuss/lib/discuss/repo.ex -----
defmodule Discuss.Repo do
  use Ecto.Repo,
    otp_app: :discuss,
    adapter: Ecto.Adapters.Postgres
end


----- /home/zakaria/sam-learn/discuss/lib/discuss/content.ex -----
defmodule Discuss.Content do
  @moduledoc """
  The Content context for managing discussion topics.
  """

  import Ecto.Query, warn: false
  alias Discuss.Repo
  alias Discuss.Content.Topic

  @doc """
  Returns a changeset for a new or existing topic.
  """
  def change_topic(%Topic{} = topic) do
    Topic.changeset(topic, %{})
  end

  @doc """
  Creates a new topic in the database.
  """
  def create_topic(attrs \\ %{}) do
    %Topic{}
    |> Topic.changeset(attrs)
    |> Repo.insert()
  end

  @doc "Lists all topics in the database."
  def list_topics do
    Repo.all(Topic)
  end

  @doc "Gets a topic by ID. ( raises if not found )"
  def get_topic!(id), do: Repo.get!(Topic, id)

  def recent_topics(limit \\ 5) do
    Topic
    |> order_by(desc: :inserted_at)
    |> limit(^limit)
    |> Repo.all()
  end

  @doc "Updates an existing topic"
  def update_topic(%Topic{} = topic, attrs) do
    topic
    |> Topic.changeset(attrs)
    |> Repo.update()
  end

  @doc "Deletes a topic"
  def delete_topic(%Topic{} = topic) do
    Repo.delete(topic)
  end

end


----- /home/zakaria/sam-learn/discuss/lib/discuss/mailer.ex -----
defmodule Discuss.Mailer do
  use Swoosh.Mailer, otp_app: :discuss
end


----- /home/zakaria/sam-learn/discuss/lib/discuss/application.ex -----
defmodule Discuss.Application do
  # See https://hexdocs.pm/elixir/Application.html
  # for more information on OTP Applications
  @moduledoc false

  use Application

  @impl true
  def start(_type, _args) do
    children = [
      DiscussWeb.Telemetry,
      Discuss.Repo,
      {DNSCluster, query: Application.get_env(:discuss, :dns_cluster_query) || :ignore},
      {Phoenix.PubSub, name: Discuss.PubSub},
      # Start the Finch HTTP client for sending emails
      {Finch, name: Discuss.Finch},
      # Start a worker by calling: Discuss.Worker.start_link(arg)
      # {Discuss.Worker, arg},
      # Start to serve requests, typically the last entry
      DiscussWeb.Endpoint
    ]

    # See https://hexdocs.pm/elixir/Supervisor.html
    # for other strategies and supported options
    opts = [strategy: :one_for_one, name: Discuss.Supervisor]
    Supervisor.start_link(children, opts)
  end

  # Tell Phoenix to update the endpoint configuration
  # whenever the application is updated.
  @impl true
  def config_change(changed, _new, removed) do
    DiscussWeb.Endpoint.config_change(changed, removed)
    :ok
  end
end


----- /home/zakaria/sam-learn/discuss/lib/discuss/content/topic.ex -----
defmodule Discuss.Content.Topic do
  use Ecto.Schema
  import Ecto.Changeset

  schema "topics" do
    field :title, :string
    field :body, :string
    timestamps()
  end

  @doc false
  def changeset(topic, attrs) do
    topic
    |> cast(attrs, [:title, :body])
    |> validate_required([:title, :body])
  end
end


